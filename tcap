#!/usr/bin/perl

# Globals
# my @pool_attr = ($user, $pass, $targets_aref, $befores_aref, $afters_aref, $commands_aref);

$DBG = 1;

# The Ur symbol.  Everything starts here.
my %pools;
my $cctag;

use Getopt::Long; # qw(:config debug);
use IO::Socket::INET;

# ***** Main

if(@ARGV < 3) {
  die "I need you to feed me commands like this: tcap <command> -f <config_file>";
}

GetOptions('clean'    => \$opt_c,
           'go'       => \$opt_g,
           'stop'     => \$opt_s,
           'pull'     => \$opt_p,
           'file=s'   => \$opt_f);

if(!defined $opt_f) {
  print "The -f argument specifying the config file to use is mandatory.\n";
  exit 1;
}

# Cram the template into memory...  When this sub exits, we can assume the
# template file was well formed, but no checks have been done on any targets.
&parse_conf($opt_f);

if($DBG) { &dump_struct(); }

$cctag = &validate_targets();

if($DBG) { &dump_struct(); }

if(defined $opt_g) {
  do_start();
} elsif (defined $opt_s) {
  do_stop();
} elsif (defined $opt_p) {
  do_pull();
} elsif (defined $opt_c) {
  do_clean();
}

# ********************* sub section ******

sub validate_targets() {
  my $first_responder;
  $time_limit = 1;

  foreach $pool (keys %pools) {
    $num_tgts = scalar @{$pools{ $pool }->[2]};
#    print  $pool  . " : " . $num_tgts . "\n";
    next if ($num_tgts == 0);

    #  iterate over all hosts, pruning the ones we can't hit off of
    #  the target list.... no point blowing time timing out on hosts.
    my $index = 0;
    $tgt_aref = $pools{ $pool }->[2];
    while( $index < scalar(@$tgt_aref)) {
#       $tmp = scalar @{$tgt_aref};
#       print "index: $index " . "size of array: $tmp\n";
       $tgt = @$tgt_aref[$index];

       if($DBG) { print "testing connection to $tgt" . "\n"; }

       eval {
         local $SIG{ALRM} = sub {
           if($DBG) { print "unable to connect to $tgt\n"; }
           splice @$tgt_aref, $index, 1;
           next;
         };

         alarm $time_limit;
         my $socket = IO::Socket::INET->new(
                          PeerAddr => $tgt,
                          PeerPort => 22,
                          Proto    => 'tcp',
                          );

         # on a _completely_ different note, set our controller tag to 
         # the IP that we use to connect to the first responsive target.
         if (!defined($first_responder) && $socket->sockhost) { 
           $first_responder = $socket->sockhost;
           if($DBG) { print "first_responder set to: $first_responder\n"; }
         }
         $index++;
         alarm 0;
       };
       alarm 0; # race protection
    }
  }
  print "\n";
  return $first_responder;
}

sub do_start() {
  print "started\n";

  # check run status
  # loop through pools and
    # run before push
    # run before pull
    # cmds

  # report errors/stats
}

sub do_stop()  {
  print "stopped\n";

  # exit if already stopped
  # loop through pools and
    # run after pull
    # run after push
    # del remote 'running' semaphores
}

sub do_pull()  {
  print "pulled\n";

  # loop through pools and 
    # check remote for dirs and run PULL:afters
}

sub do_clean() {
  print "cleaned\n";

  # warn and die if running
  # loop through pools and
    # rm all local  :clean
    # rm all remote :clean
    # kill all remote cmds
    # rmdir remote tmp dirs
    # archive local dir
}

sub parse_conf() {
  my $conf = shift;

  open(CONFFILE, "<", $conf) or die "I can't open the config file you gave me";

  while(<CONFFILE>) {
    my $line = $_;

    # clean up the input stream a bit...
    $line =~ s/#.*$//;            # comments
    if($line =~ /^ *$/) { next; } # whitespace only

	# pools are where everything starts...  Therefore, the first thing we do
	# is pull the 'POOL' lines out and populate the %pools hash...  all other operations
	# have a 'tag' argument (2nd field) that ties that operation to its pool.  We use
	# this to index into the %pools hash.
    # POOL:label:user:pass
    if($line =~ /^POOL:~:(.*):~:(.*):~:(.*):~:$/) {
#      print "P - $1 - $2 - $3\n";
      my ($label, $user, $pass) = ($1, $2, $3);

      # these null array references anchor their respective lists of
      # objects (but not _those_ kind of objects...*g*).
      my $befores_aref   = [];
      my $afters_aref    = [];
      my $commands_aref  = [];
      my $targets_aref   = [];

      my @pool_attr = ($user, $pass, $targets_aref, $befores_aref, $afters_aref, $commands_aref);

      $pools{ $label } = \@pool_attr;
    }

    # COMMAND:pool:command:when:clean:
    elsif($line =~ /^COMMAND:~:(.*):~:(.*):~:(.*):~:(.*):~:$/) {
#      print "C - $1 - $2 - $3 - $4\n";
      my ($label, $command, $epoch, $clean) = ($1, $2, $3, $4);

      # If it's the 'ALL' pool or it's attached to a pool we've seen,
      # push it into the struct... otherwise, this is a script typo
      # and we die.
      if($label =~ /ALL/) {
        foreach my $pool (keys %pools) {   
          my $cmd_aref = $pools{ $pool }[5];
          push(@$cmd_aref, $command);
        } 
      } elsif(exists $pools{ $label }) {     # Have we seen this pool name?
        my $cmd_aref = $pools{ $label }[5];
        push(@$cmd_aref, $command);
      } else {                               # No.  No we have not.
        die "Nonexistant pool referenced... terminating."
      } 
    }

    # MEMBER:label:hostname:
    elsif($line =~ /^MEMBER:~:(.*):~:(.*):~:$/) {
#      print "M - $1 - $2\n";
      my ($label, $hostname) = ($1, $2);
      if(exists $pools{ $label }) {
	    my $targets_aref = $pools{ $label }->[2];
		push(@$targets_aref, $hostname);
		$num_targets++;
	  } else {
	    die "Nonexistant pool referenced... terminating."
      }
    }

    # PUSH:label:lpath:rpath:epoch:clean:
    elsif($line =~ /^PUSH:~:(.*):~:(.*):~:(.*):~:(.*):~:$/) {
      my ($label, $lpath, $rpath, $epoch, $clean) = ($1, $2, $3, $4);
	    if($label =~ /ALL/) {
	      foreach my $pool (keys %pools) {
  
  		    if    ($epoch eq "before") { $idx = 3; }
   		    elsif ($epoch eq "after")  { $idx = 4; }
	  	    else  { die "Invalid epoch." }

	    	  my $push_aref = $pools{ $pool }->[$idx];
	    	  my @push_atom = ("PUSH", $lpath, $rpath, $clean);
	    	  push(@$push_aref, \@push_atom);
	    	}

      } elsif (exists $pools{ $label }) {
		    if ($epoch eq "before") {
          my $push_aref = $pools{ $label }->[3];
		      my @push_atom = ("PUSH", $lpath, $rpath, $clean);

		      push(@$push_aref, \@push_atom);
		      $before_push++;
		    } elsif ($epoch eq "after") {
		      my $push_aref = $pools{ $label }->[4];
		      my @push_atom = ("PUSH", $lpath, $rpath, $clean);

		      push(@$push_aref, \@push_atom);
		      $after_push++;
		    } else {
		      die "Invalid epoch: $epoch";
		    }
	    } else { die "A PUSH command referenced a pool that isn't defined. Aborting." }
    }

    # PULL:pool:lpath:rpath:epoch:
    elsif($line =~ /^PULL:~:(.*):~:(.*):~:(.*):~:(.*):~:$/) {
      my ($label, $lpath, $rpath, $epoch) = ($1, $2, $3, $4);
  	  if($label =~ /ALL/) {
  	    foreach my $pool (keys %pools) {

  		    if    ($epoch eq "before") { $idx = 3; }
  		    elsif ($epoch eq "after")  { $idx = 4; }
  		    else  { die "invalid epoch." }

  		    my $pull_aref = $pools{ $pool }->[$idx];
  		    my @pull_atom = ("PULL", $lpath, $rpath, $clean);
  		    push(@$pull_aref, \@pull_atom);
		    }
      } elsif (exists $pools{ $label }) {
	    	if ($epoch eq "before") {
          my $pull_aref = $pools{ $label }->[3];
	   	  	my @pull_atom = ("PULL", $lpath, $rpath, $clean);
		      push(@$pull_aref, \@push_atom);
		    } elsif ($epoch eq "after") {
		      my $pull_aref = $pools{ $label }->[4];
		      my @pull_atom = ("PULL", $lpath, $rpath, $clean);
		      push(@$pull_aref, \@pull_atom);
		    } else {
		      die "Invalid epoch.";
		    }
	    } else { die "A PULL command referenced a pool that isn't defined. Aborting." }
    } else {
      print "I didn't recognize this line: $line"
    }
  }

 $num_cmds = scalar @{$cmd_aref};
}

sub dump_struct() {
  while (my ($key, $value) = each(%pools)) {
	  my $pool         = $key;
	  my $user         = $$value[0];
	  my $pass         = $$value[1];
	  my $targets_aref = $$value[2];
      my $cmds_aref    = $$value[5];
	  my $befores_aref = $$value[3];
	  my $afters_aref  = $$value[4];

	  print "Pool: $pool user: $user pass: $pass\n";
	  foreach(@$targets_aref) { my $tgt = $_; print "  tgt: $tgt \n"; }
      foreach(@$cmds_aref)    { my $cmd = $_; print "  cmd: $cmd \n"; }
      foreach(@$befores_aref) { 
	    my $before = $_;
		my $cmd    = $$before[0];
		my $local  = $$before[1];
		my $remote = $$before[2];
		my $clean  = $$before[3];

		print "  before: $cmd: $local: $remote\n"; 
	  }
      foreach(@$afters_aref) { 
	    my $after = $_;
		my $cmd    = $$after[0];
		my $local  = $$after[1];
		my $remote = $$after[2];
		my $clean  = $$after[3];

		print "  after: $cmd: $local: $remote\n"; 
	  }
      print "\n";
  }
}
